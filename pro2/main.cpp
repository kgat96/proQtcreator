
//#############################################################################
//# Makefile for building: pro1
//# Generated by qmake (3.0) (Qt 5.4.1)
//# Project:  pro1.pro
//# Template: app
//# Command: qmake -spec linux-g++ CONFIG+=debug -o Makefile pro1.pro
//#############################################################################

#include <QCoreApplication>
#include <QApplication>

#include <QtCore>

#include <QWidget>

#include <QPushButton>

class Thread1 : public QThread
{
private:
    void run()
    {
        qDebug()<<"From worker thread: "<< currentThreadId();
    }
};

void test1 (QCoreApplication &ap)
{
    qDebug() << "From main thread: " << QThread::currentThreadId();

    class Thread1 *t = new Thread1();

    QObject::connect(t, SIGNAL(finished()), &ap, SLOT(quit()));

    t->start();
}

class Thread2 : public QThread
{
    Q_OBJECT

public:
    Thread2():m_stop(false)
    {}

public slots:
    void stop()
    {
        qDebug()<<"Thread::stop called from main thread: "<<currentThreadId();
        QMutexLocker locker(&m_mutex);
        m_stop = true;
    }

private:
    QMutex m_mutex;
    bool m_stop;

    void run()
    {
        qDebug()<<"From worker thread: "<<currentThreadId();
        while (1) {
            {
                QMutexLocker locker(&m_mutex);
                if (m_stop) break;
            }
            msleep(10);
        }
    }
};

void test2 (QApplication &ap)
{
    qDebug() << "Test2 From main thread: " << QThread::currentThreadId();

    QPushButton *bt = new QPushButton("Stop Thread");
    class Thread2 *t = new Thread2();

    QObject::connect(bt, SIGNAL(clicked()), t, SLOT(stop()));
    QObject::connect(t, SIGNAL(finished()), &ap, SLOT(quit()));

    t->start();
    bt->show();
}

class Thread3 : public QThread
{
    Q_OBJECT

private slots:
    void onTimeout()
    {
        qDebug()<<"Thread::onTimeout get called from? : " << QThread::currentThreadId();
    }

private:
    void run()
    {
        qDebug()<<"From worker thread: "<<currentThreadId();
        QTimer timer;
        connect(&timer, SIGNAL(timeout()), this, SLOT(onTimeout()));
        timer.start(1000);

        exec();
    }
};


void test3 (QCoreApplication &ap)
{
    qDebug() << "Test3 From main thread: " << QThread::currentThreadId();

    class Thread3 *t = new Thread3();

    t->moveToThread(t);

    t->start();
}

class Worker4 : public QObject
{
    Q_OBJECT
private slots:
    void onTimeout()
    {
        qDebug()<<"Worker::onTimeout get called from?: "<<QThread::currentThreadId();
    }
};

class Thread4 : public QThread
{
    Q_OBJECT

private:
    void run()
    {
        QTimer timer;
        Worker4 worker;

        qDebug() << "From work thread: "<< currentThreadId();

        connect(&timer, SIGNAL(timeout()), &worker, SLOT(onTimeout()));
        timer.start(1000);

        exec();
    }
};

void test4 (QCoreApplication &ap)
{
    qDebug() << "Test4 From main thread: " << QThread::currentThreadId();

    class Thread4 *t = new Thread4();

    t->start();
}

class Worker5 : public QObject
{
    Q_OBJECT
private slots:
    void onTimeout()
    {
        qDebug()<<"Worker::onTimeout get called from?: "<<QThread::currentThreadId();
    }
};

void test5 (QCoreApplication &ap)
{
    qDebug() << "Test5 From main thread: " << QThread::currentThreadId();

    class QThread *t = new QThread();

    QTimer *timer = new QTimer();
    Worker5 *worker = new Worker5();

    QObject::connect(timer, SIGNAL(timeout()), worker, SLOT(onTimeout()));
    timer->start(1000);

    /* Whether the timer thread into the main thread */
//  timer->moveToThread(t);
    worker->moveToThread(t);

    t->start();
}

class Test6 : public QObject
{
    Q_OBJECT
protected: 
    bool event(QEvent *evt)
    {
        if (evt->type() == QEvent::User) {
            qDebug()<<"Event received in thread"<<QThread::currentThreadId();
            return true;
        }
        return QObject::event(evt);
    }
};

class Button6 : public QPushButton
{
    Q_OBJECT
    Test6 *m_test;
public:
    Button6(Test6 *test):QPushButton("Send Event"), m_test(test)
    {
        connect(this, SIGNAL(clicked()), SLOT(onClicked()));
    }

private slots:
    void onClicked()
    {
        QCoreApplication::postEvent(m_test, new QEvent(QEvent::User));
    }
};

void test6 (QApplication &ap)
{
    qDebug() << "Test6 From main thread: " << QThread::currentThreadId();

    Test6 *test = new Test6();
    Button6 *btn = new Button6(test);

    QThread *th = new QThread();    //new line
    test->moveToThread(th);         //new line
    th->start();                    //new line

    btn->show();
}

#include "main.moc"
int main(int argc, char *argv[])
{
//  QCoreApplication app(argc, argv);  // test1 mode
    QApplication app(argc, argv);  // test2/test6 mode

    qDebug()<<"start\n";

    /* QThread general use */
    // test1(app);
    /* UI thread asynchronous notification method */
    // test2(app);
    /* objects located within that thread */
    // test3(app);
    /* QThread & Qtimer mixer use */
    // test4(app);
    /* how to call moveToThread */
    // test5(app);

    /* QCoreApplication::postEvent() */
    test6(app);

    qDebug()<<"quit\n";

    return app.exec();
}
